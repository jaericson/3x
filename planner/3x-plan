#!/usr/bin/env bash
# 3x-plan -- plan experiments with given variables
# Usage: 3x plan [PROGRAM] [NAME[=VALUE[,VALUE]...]]...
# 
# Use `3x inputs -v` to list available input variables.
# 
# 
# Usage: 3x plan results RESULTS_QUERY
#        3x plan skip    RESULTS_QUERY
# 
# Another way to plan experiments is based on the results.  You can narrow
# down the list of results and use the same set of inputs to plan more
# experiments.  If you want to run inputs complementary to a set of
# results, that is also possible with `3x plan skip`.  In this alternative
# usage, you can plan more runs conditioning on the outputs so far.
# 
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-07
set -eu

[ $# -ge 1 ] || {
    usage "$0" "At least program or one input variable must be given" || true
    # show available variables
    echo
    echo "For full combination of inputs, run: "
    echo "  3x plan "$(3x-inputs)
    false
}

_3X_ROOT=$(3x-findroot)
: ${_3X_BATCH:=$(new-batch-id)}
: ${_3X_BATCH_STARTING:=false}
export _3X_ROOT _3X_BATCH

# do a sanity check before we proceed
update-assembly-script >/dev/null

# create the batch directory
tmp="$_3X_ROOT/$_3X_BATCH"
trap "rm -rf $tmp" EXIT
mkdir -p -- "$tmp"

# knowing how to generate combinations is important
permute() {
    local prefix=$1; shift
    if [[ $# == 0 ]]; then
        echo "$prefix"
    else
        local varSpec=$1; shift
        local name=${varSpec%%=*}
        local OIFS=$IFS
        IFS=,
        local values=(${varSpec#$name=})
        IFS=$OIFS
        local value=
        prefix+=" $name="
        for value in "${values[@]}"; do
            permute "$prefix$value" "$@"
        done
    fi
}

# decide how we want to plan this batch
case $1 in
    with) # based on the given files
        shift
        # adjust _3X_ROOT-relative paths
        [ $# -eq 0 ] || [ -e "$1" ] || ! [ -e "$_3X_ROOT/$1" ] || {
            path=$1; shift
            set -- "$_3X_ROOT/$path" "$@"
        }
        [ -t 1 ] || EDITOR=true
        {
            cat "$@"
            echo
        } >"$tmp"/plan.editing
        # clean up any temporary file
        case $(readlink -f "$1") in
            "$_3X_ROOT/.3x/plan.editing".*)
                rm -f "$1"
                ;;
        esac
        ;;
    results|skip) # based on query over results
        results=$1; shift
        invertResults=false; case $results in skip) invertResults=true ;; esac

        # record the query and fetch the results
        echo "$@" >"$tmp"/plan.$results.query
        3x-results "$@" >"$tmp"/plan.$results

        # transform the results into a batch plan
        cut -f$(( 1 + $(3x-outputs | wc -l) + 1 ))- <"$tmp"/plan.$results |
        if $invertResults; then # TODO invert from the combination
            excl="$tmp"/plan.skipped
            sort | column -t >"$excl"
            permute "" $(normalize-inputs -v \
                $(tr ' \t' '\n' <"$excl" | sed -n 's/=.*//p' | sort -u)) |
                sort | column -t |
            comm -13 "$excl" -
        else awk '!seen[$0] {seen[$0]++;print}' # filter duplicate inputs
        fi |
        sed 's/^/3x[[:space:]][[:space:]]*run[[:space:]][[:space:]]*/' | column -t >"$tmp"/plan.editing
        ;;
    *) # by editing combinations generated from given input values
        # normalize command-line arguments
        args=($(normalize-inputs -nv "$@"))
        [ ${#args[@]} -eq 0 ] && set -- || set -- "${args[@]}"

        # permute the arguments and generate a batch plan
        msg "Permuting inputs for ${@%%=*}..."
        permute "3x run" "$@" | column -t >"$tmp"/plan.editing
        ;;
esac

cd "$_3X_ROOT/$_3X_BATCH"

# let user do a finish edit of the generated plan
if edit plan.editing plan.in-progress; then
    trap - EXIT
    sanitize() {
        local i=$1 o=$2
        # check if every line starts with `3x run '
        ! grep -Hn -E -v '^3x[[:space:]]+run[[:space:]]+|^[[:space:]]*$' "$i" ||
            error "Syntax Error: All plan lines must start with \`3x run '" || return $?
        # discard empty lines
        grep -E -v '^[[:space:]]*$' <"$i" >"$o"
        # Skip checks of serials at the end of each line, since this is 3x-starts' job
        #! grep -E -v '[[:space:]]+#[[:digit:]]+$' "$o" ||
        #    error "$_3X_BATCH/$i"': all plan lines must end with #SERIAL where SERIAL is a decimal number'
        # TODO check whether all input values are sane
    }
    sanitize plan.editing plan.editing.sanitized || {
        cd "$_3X_ROOT"
        # do not leave a bogus _3X_BATCH, but clean it up
        tmp=$(mktemp .3x/plan.editing.XXX)
        cat "$_3X_BATCH"/plan.editing >$tmp
        rm -rf "$_3X_BATCH"
        msg "Edit the file and retry with the following command:"
        msg "  3x plan with $tmp"
        false
    }
    rm -f plan.editing
    mv -f plan.editing.sanitized plan
else
    error "Aborted planning"
fi

# and the batch creation is done
msg +0 -n "Batch created at "
if $_3X_BATCH_STARTING; then
    msg +0 "$_3X_BATCH"
else
    echo "$_3X_BATCH"
    msg "To start the batch, run:"
    msg "  3x start $_3X_BATCH"
fi

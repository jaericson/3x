#!/usr/bin/env bash
# exp-plan -- plan experiments with given variables
# Usage: exp plan [PROGRAM] [NAME[=VALUE[,VALUE]...]]...
# 
# Use `exp conditions -v` to list available condition variables.
# 
# 
# Usage: exp plan results RESULTS_QUERY
#        exp plan skip    RESULTS_QUERY
# 
# Another way to plan experiments is based on the results.  You can narrow
# down the list of results and use the same set of conditions to plan more
# experiments.  If you want to run conditions complementary to a set of
# results, that is also possible with `exp plan skip`.  In this alternative
# usage, you can plan more runs conditioning on the measurements so far.
# 
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-07
set -eu

[ $# -ge 1 ] || {
    usage "$0" "At least program or one condition variable must be given" || true
    # show available variables
    echo
    echo "For full combination of conditions, run: "
    echo "  exp plan "$(exp-conditions)
    false
}

: ${EDITOR:=vim}
: ${EXPROOT:=$(exp-findroot)}
: ${EXPBATCH:=$(new-batch-id)}
export EXPROOT EXPBATCH

# create the batch directory
tmp="$EXPROOT/$EXPBATCH"
trap "rm -rf $tmp" EXIT
mkdir -p "$tmp"

# knowing how to generate combinations is important
permute() {
    local prefix=$1; shift
    if [[ $# == 0 ]]; then
        echo "$prefix"
    else
        local varSpec=$1; shift
        local name=${varSpec%%=*}
        local OIFS=$IFS
        IFS=,
        local values=(${varSpec#$name=})
        IFS=$OIFS
        local value=
        prefix+=" $name="
        for value in "${values[@]}"; do
            permute "$prefix$value" "$@"
        done
    fi
}

# decide how we want to plan this batch
case $1 in
    with) # based on the given files
        shift
        EDITOR=true
        cat "$@" |
        sed 's/^\(^exp[ 	]*run[ 	]*\)\?/exp run /' | column -t >"$tmp"/plan
        ;;
    results|skip) # based on query over results
        results=$1; shift
        invertResults=false; case $results in skip) invertResults=true ;; esac

        # record the query and fetch the results
        echo "$@" >"$tmp"/plan.$results.query
        exp-results "$@" >"$tmp"/plan.$results

        # transform the results into a batch plan
        cut -f$(( 1 + $(exp-measures | wc -l) + 1 ))- <"$tmp"/plan.$results |
        if $invertResults; then # TODO invert from the combination
            excl="$tmp"/exp.planning.exclusion
            sort | column -t >"$excl"
            permute "" $(normalize-conditions -v \
                $(tr ' \t' '\n' <"$excl" | sed -n 's/=.*//p' | sort -u)) |
                sort | column -t |
            comm -13 "$excl" -
        else awk '!seen[$0] {seen[$0]++;print}' # filter duplicate conditions
        fi |
        sed 's/^/exp run /' | column -t >"$tmp"/plan
        ;;
    *) # by editing combinations generated from given condition values
        # normalize command-line arguments
        args=($(normalize-conditions -nv "$@"))
        [ ${#args[@]} -eq 0 ] && set -- || set -- "${args[@]}"

        # permute the arguments and generate a batch plan
        msg "Permuting conditions for ${@%%=*}..."
        permute "exp run" "$@" | column -t >"$tmp"/plan
        ;;
esac

cd "$EXPROOT"

# let user do a finish edit of the generated plan
case $EDITOR in
    true)
        trap - EXIT
        ;;
    *)
        progress="$EXPBATCH"/exp.planning.in-progress
        touch -r "$EXPBATCH"/plan "$progress"
        $EDITOR "$EXPBATCH"/plan
        if [ "$EXPBATCH"/plan -nt "$progress" ]; then
            rm -f "$progress"
            trap - EXIT
        else
            error "Aborted planning"
        fi
        ;;
esac

# and the batch creation is done
msg +0 -n "Batch created at "
echo "$EXPBATCH"
if ! ${EXPBATCH_STARTING:-false}; then
    msg "To start the batch, run:"
    msg "  exp start $EXPBATCH"
fi

#!/usr/bin/env bash
# exp-index -- manage index of experiment results
# Usage:
#   exp index init
# 
#   exp index rebuild
#   exp index update RUN...
# 
#   exp index query QUERY...
#     See compile-where(1) for QUERY.
# 
# Index resides at $EXPROOT/.exp/index.db, and it is an SQLite database
# mirroring the input and output values for each run.
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-03-08
set -eu

[ $# -gt 0 ] || usage "$0" "Specify what to do with the inex"

BATCHSIZE=256

EXPROOT=$(exp-findroot)
export EXPROOT

. "$TOOLSDIR"/sql-vocabs.sh

EXPINDEX="$EXPROOT"/.exp/index.db
sqlite() { sqlite3 "$EXPINDEX"; }

inputs=$(exp-inputs)
outputs=$(exp-outputs)
columns="$outputs $inputs"

Cmd=$1; shift
case $Cmd in
    init|migrate)
        ## initialize index if necessary
        sql-create-table() {
            cat <<-EOF
		CREATE TABLE IF NOT EXISTS run
		( id TEXT PRIMARY KEY
		$(
		for varName in $columns; do
		    echo ", _$varName $(sql-type $varName) DEFAULT NULL"
		done
		)
		)
		EOF
        }
        if ! [ -s "$EXPINDEX" ]; then
            sqlite <<-EOF
                BEGIN TRANSACTION;
		$(sql-create-table);
		COMMIT TRANSACTION;
		EOF
        elif [ x"$Cmd" = x"migrate" -o "$EXPROOT/.exp/assemble.sh" -nt "$EXPINDEX" ]; then
            # if $inputs and/or $outputs have changed, migrate indexed data
            oldColumns=$(
                sqlite <<<".schema run" |
                sed -n '/^, _/ { s/^, _//; s/ .*$//; p; }'
                )
            selectColumns="id"
            for varName in $columns; do
                grep -qF "$varName" <<<"$oldColumns" || continue
                selectColumns+=", _$varName"
            done
            sqlite <<-EOF
                BEGIN TRANSACTION;
		ALTER TABLE run RENAME TO run_$$;
		$(sql-create-table);
		INSERT INTO run ($selectColumns) SELECT $selectColumns FROM run_$$;
		DROP TABLE run_$$;
		COMMIT TRANSACTION;
		EOF
        fi
        ;;

    query)
        header="run#" cols="id"
        for varName in $columns; do
            header+="\t$varName"
            cols+=", _$varName"
        done
        # compile selection expression from arguments
        where=$(compile-where "$@")
        echo -e "$header"
        sqlite <<-EOF
	.header OFF
	.mode tabs
	.nullvalue ""
	SELECT $cols FROM run $where;
	EOF
        ;;

    update)
        [ -s "$EXPINDEX" ] || error "No index exists"
        # prepare some vocabularies based on log level
        run-sqlite() { sqlite "$@"; }
        progress() { :; }
        verbosity-isnt +1 || progress() { msg "Indexing $*..."; }
        verbosity-isnt +2 || run-sqlite() { tee /dev/stderr | sqlite "$@"; }
        be-quiet +3       || set -x
        # prepare code for generating SQL statements
        esc= vars= fmt=
        for varName in $columns; do
            case $(sql-type $varName) in
                TEXT)
                    esc+=" $varName=\${$varName:+\"'\"\${$varName//\"'\"/\"''\"}\"'\"}"
                    ;;
            esac
            vars+="\"\${$varName:-NULL}\"" fmt+="%s"
            vars+=' ' fmt+=',\t'
        done
        printRecordExpr="source input; source output;
                    $esc; printf \"($fmt'%s')\" $vars"
        {
            # scan given RUNs and generate VALUES for SQL INSERT statement
            numRecs=0
            for run; do
                if [[ $numRecs -eq 0 ]]; then
                    echo "INSERT OR REPLACE INTO run"
                    echo "($(printf "_%s,\t" $columns)id) VALUES "
                else
                    echo ","
                fi
                (
                    cd "$run"
                    id=$(pwd -P); id=${id#$EXPROOT/}
                    progress "$id"
                    eval "$printRecordExpr '$id'"
                )
                let ++numRecs
                if [[ $numRecs -gt $BATCHSIZE ]]; then
                    echo ";"
                    numRecs=0
                fi
            done
            [[ $numRecs -eq 0 ]] || echo ";"
        } | run-sqlite
        ;;

    rebuild)
        # make sure index is initialized
        EXPKIT_LOGLVL=$(($EXPKIT_LOGLVL+1)) 
        exp-index init
        # find all runs and update
        msg "Rebuilding index..."
        find-rundirs "$EXPROOT"/run |
        sed 's:/output$::' |
        xargs exp-index update
        ;;

    *)
        usage "$0" "$Cmd: unknown index command"
        ;;
esac

#!/usr/bin/env bash
# exp-results -- enumerate experiment outputs with inputs
# Usage: exp results [-t] [BATCH | RUN]... QUERY...
# 
# You can specify from which BATCH or RUNs you want to enumerate the results.
# Otherwise, results from all runs will be filtered and listed.
# To list all results from the entire set of runs, use:
# 
#     exp results run
# 
# A QUERY in the form of [NAME[[=|<>|!=]VALUE[,VALUE]... | [<|<=|>=|>]VALUE]]
# can be specified after the BATCH and RUNs, and only the results satisfying
# them will be listed.  Use `exp inputs -v` to see available input variables
# and values.  For the defined output variables, use `exp outputs` to see their
# names and types.
# 
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-07
set -eu

[ $# -gt 0 ] || usage "$0" "At least a RUN/BATCH directory or input variable must be given"

EXPROOT=$(exp-findroot)
export EXPROOT

verboseFiltering=
verbosity-isnt +5 || verboseFiltering="bash -x"
verbosity-isnt +4 || set -x

## from command-line, find the batches and runs
runs=()
args=()
for a; do
    p=$(readlink -f "$a")
    p=${p#$EXPROOT/}
    case $p in
        run/batch/*)
            runs+=("${a%/}"/runs/*/)
            ;;
        run/*)
            runs+=("$a")
            ;;
        *) # neither a batch nor run dir
            args+=("$a")
            ;;
    esac
done
# search from all runs if no scope was given
[[ ${#runs[@]} -gt 0 ]] || runs+=("$EXPROOT"/run)
[[ ${#args[@]} -eq 0 ]] && set -- || set -- "${args[@]}"
msg +1 "Considering runs under ${runs[*]}"

## normalize rest of the command-line arguments
msg +2 "Normalizing filter $*"
args=($(normalize-inputs -p "$@" | grep -v '=$' || true))
[ ${#args[@]} -eq 0 ] && set -- || set -- "${args[@]}"

## try index first
set -o pipefail
if ! exp-index query "$@" | {
    # TODO only when not using plain tab separated format
    read header
    OFS=$IFS; IFS=$'\t'; set -- $header; IFS=$OFS
    labelAwk= i=2; shift
    for varName; do
        labelAwk+=", \"$varName=\"\$$i"
        let ++i
    done
    awk -F $'\t' '{print $1, '"${labelAwk#,}"'}'
}; then

## and fallback to scanning raw data
msg +2 "Compiling filter $*"
filter=$(mktemp ${TMPDIR:-/tmp}/exp-results-filter.XXXXXX)
trap "rm -f $filter" EXIT
compile-filter "$@" >"$filter"
chmod +x "$filter"
if [ $# -gt 0 ]; then
    findPredicate=(-exec $verboseFiltering "$filter" {} \;)
else
    findPredicate=(-true)
fi

## find matching inputs to get outputs
msg +1 "Filtering results with $*"
find-rundirs "${runs[@]}" -- "${findPredicate[@]}" |
{
    cd "$EXPROOT"
    while read -r run; do
        output=$run/output
        input=$run/input
        [ -r "$output" ] || continue
        # TODO support a plain tab separated format
        echo "$run"$'\t'"$(tr '\n' '\t' <"$output")$((sort | tr '\n' '\t') <"$input")"
    done
}

fi |
if [ -t 1 ]; then column -t; else cat; fi

#!/usr/bin/env bash
# exp-results -- enumerate experiment outputs with inputs
# Usage: exp results [BATCH | RUN]... [NAME[[=|<>|!=]VALUE[,VALUE]... | [<|<=|>=|>]VALUE]]...
# 
# You can specify from which BATCH or RUNs you want to enumerate the results.
# Otherwise, results from all runs will be filtered and listed.
# To list all results from the entire set of runs, use:
# 
#     exp results run
# 
# Furthermore, if you specify inputs after the BATCH and RUNs, only the
# results satisfying them will be listed.  Use `exp inputs -v` to see
# available input variables and values.  For the defined output variables,
# use `exp outputs` to see their names and types.
# 
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-07
set -eu

[ $# -gt 0 ] || usage "$0" "At least a RUN/BATCH directory or input variable must be given"

EXPROOT=$(exp-findroot)
export EXPROOT

verboseFiltering=
if ! be-quiet +3; then
    if be-quiet +4 || ! be-quiet +5; then
        set -x
    else
        verboseFiltering="bash -x"
    fi
fi


## from command-line, find the batches and runs
runs=()
args=()
for a; do
    p=$(readlink -f "$a")
    p=${p#$EXPROOT/}
    case $p in
        run/batch/*)
            runs+=("${a%/}"/runs/*/)
            ;;
        run/*)
            runs+=("$a")
            ;;
        *) # neither a batch nor run dir
            args+=("$a")
            ;;
    esac
done
# search from all runs if no scope was given
[[ ${#runs[@]} -gt 0 ]] || runs+=("$EXPROOT"/run)
[[ ${#args[@]} -eq 0 ]] && set -- || set -- "${args[@]}"
msg +1 "Considering runs under ${runs[*]}"

## normalize rest of the command-line arguments
msg +2 "Normalizing filter $*"
args=($(normalize-inputs -p "$@" | grep -v '=$' || true))
[ ${#args[@]} -eq 0 ] && set -- || set -- "${args[@]}"

msg +2 "Compiling filter $*"
filter=$(mktemp ${TMPDIR:-/tmp}/exp-results-filter.XXXXXX)
trap "rm -f $filter" EXIT
compile-filter "$@" >"$filter"
chmod +x "$filter"
if [ $# -gt 0 ]; then
    findPredicate=(-exec $verboseFiltering "$filter" {} \;)
else
    findPredicate=(-true)
fi

## find matching inputs to get outputs
msg +1 "Filtering results with $*"
find "${runs[@]}" \
    -type d \( -name workdir -o -name measures -o -name running.\* \) -prune -o \
    -name output \( "${findPredicate[@]}" \) \
    -print |
while read -r output; do
    run=${output%/output}
    run=$(cd "$run" && pwd -P); run=${run#$EXPROOT/}
    input=$run/input
    [ -r "$output" ] || continue
    echo "$run"$'\t'"$(tr '\n' '\t' <"$output")$((sort | tr '\n' '\t') <"$input")"
done |
if [ -t 1 ]; then column -t; else cat; fi

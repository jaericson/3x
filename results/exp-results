#!/usr/bin/env bash
# exp-results -- enumerate experiment outcomes
# Usage: exp results [BATCH | RUN]... [NAME[[=|<>|!=]VALUE[,VALUE]... | [<|<=|>=|>]VALUE]]...
# 
# You can specify from which BATCH or RUNs you want to enumerate the results.
# Otherwise, results from all runs will be filtered and listed.
# To list all results from the entire set of runs, use:
# 
#     exp results run
# 
# Furthermore, if you specify conditions after the BATCH and RUNs, only the
# results satisfying them will be listed.  Use `exp conditions -v` to see
# available condition variables and values.  For the defined measurements,
# use `exp measures` to see their names and types.
# 
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-07
set -eu

[ $# -gt 0 ] || usage "$0" "At least a RUN/BATCH directory or condition variable must be given"

: ${EXPROOT:=$(exp-findroot)}
export EXPROOT

verboseFiltering=
if ! be-quiet +3; then
    if be-quiet +4 || ! be-quiet +5; then
        set -x
    else
        verboseFiltering="bash -x"
    fi
fi


## from command-line, find the batches and runs
runs=()
args=()
for a; do
    p=$(readlink -f "$a")
    p=${p#$EXPROOT/}
    case $p in
        run/batch/*)
            runs+=("${a%/}"/runs/*/)
            ;;
        run/*)
            runs+=("$a")
            ;;
        *) # neither a batch nor run dir
            args+=("$a")
            ;;
    esac
done
# search from all runs if no scope was given
[[ ${#runs[@]} -gt 0 ]] || runs+=("$EXPROOT"/run)
[[ ${#args[@]} -eq 0 ]] && set -- || set -- "${args[@]}"
msg +1 "Considering runs under ${runs[*]}"

## normalize rest of the command-line arguments
msg +2 "Normalizing filter $*"
args=($(normalize-conditions -p "$@" | grep -v '=$' || true))
[ ${#args[@]} -eq 0 ] && set -- || set -- "${args[@]}"

msg +2 "Compiling filter $*"
filter=$(mktemp ${TMPDIR:-/tmp}/exp-results-filter.XXXXXX)
trap "rm -f $filter" EXIT
compile-filter "$@" >"$filter"
chmod +x "$filter"
if [ $# -gt 0 ]; then
    findPredicate=(-exec $verboseFiltering "$filter" {} \;)
else
    findPredicate=(-true)
fi

## find matching conditions to get outcomes
msg +1 "Filtering results with $*"
find "${runs[@]}" -name exp.outcome \
    "${findPredicate[@]}" -print |
while read -r outcome; do
    run=${outcome%/exp.outcome}
    run=$(cd "$run" && pwd -P); run=${run#$EXPROOT/}
    condition=$run/exp.condition
    [ -r "$outcome" ] || continue
    echo "$run"$'\t'"$(tr '\n' '\t' <"$outcome")$((sort | tr '\n' '\t') <"$condition")"
done |
if [ -t 1 ]; then column -t; else cat; fi

#!/usr/bin/env bash
# dequeue -- execute runs in the plan and running list of current queue and
#            move finished ones to the done list
# See runner.sh for extending and overriding base runners behavior.
# 
# Usage:
# > . runner.sh
# > dequeue
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-07-11
set -eu
. runner.sh

runDir=
cmdln=
serial=
runId=
errorRecord=

queue-record() {
    local state=$1
    echo $state ${cmdln#run } "#$serial $_3X_TARGET $runId"
}

# mark as ABORTED upon queue-stop or interrupt
exit-after-marking-as-aborted() {
    c=$?
    if [ -n "$serial" -a -n "$runDir" ]; then
        # "run" finishing with non-zero exit status indicates runner error, i.e.,
        # runner not being able to finish execution properly.  So, mark the run as
        # aborted, and keep it intact in the running list for later resumption.
        state=ABORTED
        record-aborted() {
            touch running
            {
                ! grep -q " #$serial " running ||
                    echo "g/ #$serial /d"
                echo '$a'
                queue-record ABORTED
                echo .
                echo wq
            } | ed running >/dev/null
        }
        synchronized running.lock  record-aborted
        # the cause is recorded in $runDir/error
        if [ -e "$errorRecord" -o $# -gt 0 ]; then
            chmod +w $runDir/run/
            if [ $# -gt 0 ]; then
                {
                    printf '%s\n' "$@"
                    ! [ -r "$errorRecord" ] || cat "$errorRecord"
                } >$runDir/run/target.aborted
            else
                ln -fn "$errorRecord" $runDir/run/target.aborted
            fi
            # TODO archive $runDir/run/target.aborted again?
            chmod -w $runDir/run/
        fi
    fi
    exit $c
}
for sig in INT QUIT TERM; do
    case $sig in
        TERM) msg="Execution stopped" ;;
        *) msg="Execution interrupted" ;;
    esac
    trap 'exit-after-marking-as-aborted "'"$msg"'"' $sig
done

pick-next() {
    # check if there were anything running which isn't alive
    for r in $RUNDIR_PREFIX*/; do
        r=${r%/}
        [ -d "$r" ] || continue
        [ -s "$r"/cmdln ] || continue
        ! lockproc $r/lock alive || continue
        lockproc $r/lock grab || continue
        runner-msg +2 "resuming $r..."
        runDir=$r; break
    done
    # resume running if so, or dequeue from the plan
    if [ -d "$runDir" ]; then
        runId=$(cat $runDir/runId || new-run-id)
        serial=${runDir#$RUNDIR_PREFIX}
        cmdln=$(cat $runDir/cmdln)
    else
        # determine serial number
        serial=$(cat $SERIAL_COUNTER 2>/dev/null || echo 0)
        let ++serial
        # prepare a run dir
        runDir=$RUNDIR_PREFIX$serial
        mkdir -p $runDir
        lockproc $runDir/lock grab
        # determine a fresh run id
        runId=$(new-run-id | tee $runDir/runId)
        # dequeue one planned run
        { echo "1w $runDir/cmdln"; echo 1d; echo wq; } | ed plan &>/dev/null
        cmdln=$(cat $runDir/cmdln)
        # increment serial counter
        echo $serial >$SERIAL_COUNTER
    fi
    errorRecord="$_3X_QUEUE_DIR"/$runDir/error
}
synchronized plan.lock  pick-next || continue

record-running() {
    # book-keep the running list and symlink to actual run
    touch running
    {
        ! grep -q " #$serial " running ||
            echo "g/ #$serial /d"
        echo '$a'
        queue-record RUNNING
        echo .
        echo wq
    } | ed running >/dev/null
    runRelPath="../../../${runId#run/}"
    ln -sfn "$runRelPath" $runDir/run
}
synchronized running.lock  record-running

# prepare to execute the one we picked for next
# TODO make sure the $cmdln starts with "run "

# keep a copy of the target execution environment configuration and target name for later maintenance
rsync -aH --delete --link-dest="$_3X_WORKER_DIR/target/" "$_3X_WORKER_DIR/target/" $runDir/target/

# XXX clean $runId first, in case we are retrying one that failed last time
! [ -e $runDir/run/ ] || unarchive "$_3X_ARCHIVE" $runDir/run/
rm -rf $runDir/run/ 2>/dev/null || true
rm -f "$errorRecord"


# execute the picked one
# XXX count=$(($(wc -l <done) + $(wc -l <running) + $(wc -l <plan)))
count=$(( $serial + $(wc -l <plan) ))
runner-msg "Executing #$serial/$count as $runId"
# NOTE the following invokes the run command, which in turn invokes run.assemble, run.execute and run.store
_3X_LOGERROR=$errorRecord \
_3X_RUNNER_DIR=$runDir \
_3X_RUN=$runId \
$cmdln ||
    exit-after-marking-as-aborted

# we can determine the resulting state of the run after execution
state=DONE
# it is a user program failure when the output isn't complete
[[ ! -s $runDir/run/outputs.failed && -s $runDir/run/output ]] ||
    state=FAILED


# record the run in the "done" list with its state
record-finished() {
    queue-record  $state >>done
    # book-keep the running list
    touch running
    {
        ! grep -q " #$serial " running ||
            echo "g/ #$serial /d"
        echo wq
    } | ed running >/dev/null
}
synchronized running.lock  record-finished

# no more ABORTED upon signals
trap - INT QUIT TERM


# clean up
rm -rf "$runDir"
#lockproc $runDir/lock release || true # no need to release the removed lock

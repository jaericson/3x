#!/usr/bin/env bash
# queue-start -- Start executing locally the runs in the current queue
# 
# > . find-queue-runner.sh
# > setsid queue-start
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-17
set -eu

. local-runner.sh

cd "$queueDir"

if ! [ -s plan ] && [[ $(find $RUNDIR_PREFIX*/cmdln 2>/dev/null | wc -l) == 0 ]]; then
    rm -rf $RUNDIR_PREFIX*/
    msg "Nothing to run for $queue"
    exit 2
fi

# register worker pid
workerHandle=
register-pid() {
    local id=0
    local handle=
    while handle=$WORKER_LOCK_PREFIX-$id.lock
        lockproc $handle alive
    do let ++id
    done
    lockproc $handle grab
    workerHandle=$handle
}
synchronized $WORKER_LOCK_PREFIX.lock register-pid

# mark queue as active
{
    date +"# %FT%T%:z"
    echo "start $*"
} >>$ACTIVE_FLAG

# repeat until all planned runs are done
msg "Starting $queue"
abort=false
trap "abort=true" INT QUIT TERM
# TODO wait for plan to become non-empty
while [ -s plan ] && ! $abort; do
    runDir=
    cmdln=
    serial=
    runId=
    pick-next() {
        # check if there were anything running which isn't alive
        for r in $RUNDIR_PREFIX*/; do
            r=${r%/}
            [ -d "$r" ] || continue
            [ -s "$r"/cmdln ] || continue
            ! lockproc $r/lock alive || continue
            lockproc $r/lock grab || continue
            msg +2 " resuming $r..."
            runDir=$r; break
        done
        # resume running if so, or dequeue from the plan
        if [ -d "$runDir" ]; then
            runId=$(cat $runDir/runId || new-run-id)
            serial=${runDir#$RUNDIR_PREFIX}
            cmdln=$(cat $runDir/cmdln)
        else
            # determine serial number
            serial=$(cat count 2>/dev/null || echo 0)
            let ++serial
            # prepare a run dir
            runDir=$RUNDIR_PREFIX$serial
            mkdir -p $runDir
            lockproc $runDir/lock grab
            # determine a fresh run id
            runId=$(new-run-id | tee $runDir/runId)
            # dequeue one planned run
            cmdln=$(head -n 1 plan | tee $runDir/cmdln)
            { echo 1d; echo wq; } | ed plan &>/dev/null
            # increment serial count
            echo $serial >count
        fi
    }
    synchronized plan.lock  pick-next || continue
    # prepare to run the one we picked for next
    count=$(($serial + $(wc -l <plan)))
    msg "Running #$serial/$count of $queue as $runId"
    queue-record() { echo $cmdln "#$serial $target $runId"; }
    record-running() {
        # book-keep the running list and symlink to actual run
        [ -e running ] && grep -q " #$serial " running ||
            queue-record >>running
        mkdir -p runs
        runRelPath="../../../${runId#run/}"
        ln -sfn "$runRelPath" $runDir/run
        ln -sfn "$runRelPath" runs/$serial
    }
    synchronized running.lock  record-running
    # TODO copy the target execution environment configuration to $runDir
    #cp -a "$targetDir" $runDir/target
    # XXX clean $runId first, in case we are retrying one that failed last time
    ! [ -e runs/$serial/ ] || unarchive "$_3X_ARCHIVE" runs/$serial/
    rm -rf runs/$serial/ 2>/dev/null || true
    # run the picked one, using the environment as configured in target
    _3X_RUN_ENVIRON="$targetDir"/environ \
    _3X_RUN=$runId \
        $cmdln || true
    ! $abort || break
    # after it ends, record the run in the "done" list
    record-finished() {
        queue-record >>"done"
        # book-keep the running list
        {
            echo "g/ #$serial /d"
            echo wq
        } | ed running &>/dev/null
    }
    synchronized running.lock  record-finished
    rm -rf "$runDir"
    #lockproc $runDir/lock release || true # no need to release the removed lock
done

# unregister worker pid
lockproc $workerHandle release

if $abort; then
    error "Aborted $queue" || true
    queue-refresh
    msg "To resume, run:"
    msg "  3x start"
    exit 2
else
    # TODO recognize signal from queue-stop and say "Stopped"
    msg "Done $queue"
fi

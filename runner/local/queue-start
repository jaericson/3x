#!/usr/bin/env bash
# > 3x start
# Starts a new worker for locally executing runs in the current queue on this
# machine.  You can start as many as you want to execute runs in parallel.
#
# queue-start -- Start executing locally the runs in the current queue
# 
# > . find-queue-runner.sh
# > setsid queue-start
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-17
set -eu

. local-runner.sh

cd "$queueDir"

# register worker pid
workerId= workerHandle=
register-pid() {
    workerId=0
    local handle=
    while handle=$WORKER_LOCK_PREFIX-$workerId.lock
        lockproc $handle alive
    do let ++workerId
    done
    lockproc $handle grab
    workerHandle=$handle
}
synchronized $WORKER_LOCK_PREFIX.lock register-pid

# mark queue as active
{
    date +"# %FT%T%:z"
    echo "start $*"
} >>$ACTIVE_FLAG

workerMsgPrefix="$queue $target[$workerId]: "
worker-msg()   { msg   "$workerMsgPrefix$*"; }
worker-error() { error "$workerMsgPrefix$*"; }

# repeat until all planned runs are done
worker-msg "Starting"
stopped=false
abort=false
trap "stopped=true abort=true" INT QUIT
trap "stopped=true" TERM
trap 'worker-msg "Resuming"' $WORKER_WAITING_SIGNAL
while :; do
    # wait for plan to become non-empty
    until [ -s plan ] || $stopped; do
        worker-msg "Waiting"
        touch $workerHandle$WORKER_WAITING_SUFFIX
        sleep 300 &>/dev/null || true
    done
    rm -f $workerHandle$WORKER_WAITING_SUFFIX
    ! $stopped || break
    [ -s plan ] || continue
    runDir=
    cmdln=
    serial=
    runId=
    pick-next() {
        # check if there were anything running which isn't alive
        for r in $RUNDIR_PREFIX*/; do
            r=${r%/}
            [ -d "$r" ] || continue
            [ -s "$r"/cmdln ] || continue
            ! lockproc $r/lock alive || continue
            lockproc $r/lock grab || continue
            msg +2 " resuming $r..."
            runDir=$r; break
        done
        # resume running if so, or dequeue from the plan
        if [ -d "$runDir" ]; then
            runId=$(cat $runDir/runId || new-run-id)
            serial=${runDir#$RUNDIR_PREFIX}
            cmdln=$(cat $runDir/cmdln)
        else
            # determine serial number
            serial=$(cat count 2>/dev/null || echo 0)
            let ++serial
            # prepare a run dir
            runDir=$RUNDIR_PREFIX$serial
            mkdir -p $runDir
            lockproc $runDir/lock grab
            # determine a fresh run id
            runId=$(new-run-id | tee $runDir/runId)
            # dequeue one planned run
            cmdln=$(head -n 1 plan | tee $runDir/cmdln)
            { echo 1d; echo wq; } | ed plan &>/dev/null
            # increment serial count
            echo $serial >count
        fi
    }
    synchronized plan.lock  pick-next || continue
    # prepare to run the one we picked for next
    # XXX count=$(($(wc -l <done) + $(wc -l <running) + $(wc -l <plan)))
    count=$(($serial + $(wc -l <plan)))
    worker-msg "Running #$serial/$count as $runId"
    queue-record() { echo $cmdln "#$serial $target $runId"; }
    record-running() {
        # book-keep the running list and symlink to actual run
        [ -e running ] && grep -q " #$serial " running ||
            queue-record >>running
        mkdir -p runs
        runRelPath="../../../${runId#run/}"
        ln -sfn "$runRelPath" $runDir/run
        ln -sfn "$runRelPath" runs/$serial
    }
    synchronized running.lock  record-running
    # TODO copy the target execution environment configuration to $runDir
    #cp -a "$targetDir" $runDir/target
    # XXX clean $runId first, in case we are retrying one that failed last time
    ! [ -e runs/$serial/ ] || unarchive "$_3X_ARCHIVE" runs/$serial/
    rm -rf runs/$serial/ 2>/dev/null || true
    # run the picked one, using the environment as configured in target
    _3X_RUN_ENVIRON="$targetDir"/environ \
    _3X_RUN=$runId \
        $cmdln || true
    ! $stopped || break
    # after it ends, record the run in the "done" list
    record-finished() {
        queue-record >>"done"
        # book-keep the running list
        {
            echo "g/ #$serial /d"
            echo wq
        } | ed running &>/dev/null
    }
    synchronized running.lock  record-finished
    rm -rf "$runDir"
    #lockproc $runDir/lock release || true # no need to release the removed lock
done

# unregister worker pid
lockproc $workerHandle release

if $abort; then
    worker-error "Aborted" || true
    queue-refresh
    if ! [ -e $ACTIVE_FLAG ]; then
        msg "To restart, run:"
        msg "  3x start"
    fi
    exit 2
else
    worker-msg "Stopped"
fi

#!/usr/bin/env bash
# queue-start -- Start executing locally runs in the current queue
# Usage: . find-queue-runner.sh; cd "$queueDir"; queue-start
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-17
set -eu

synchronized() {
    local Lock=$1; shift
    until lockproc $Lock grab; do sleep 1; done
    "$@"
    lockproc $Lock release
}

# prepare a remaining queue based on the plan
# TODO get rid of count
# TODO rename remaining to plan
# TODO no more serial on plan
if ! [ -e remaining -a -s count -a -d runs ]; then
    initialize() {
        msg "Initializing $queue"
        # append serial numbers to each line unless all lines already have one
        if grep -q -E -v '#[0-9]+$' <plan; then
            mv -f plan plan.orig
            sed 's/#[0-9][0-9]*$//' <plan.orig >plan
            serialOnEachLine plan >remaining
        else
            cat plan >remaining
        fi
        chmod a-w plan
        wc -l <plan >count
        mkdir -p runs
    }
    synchronized remaining.lock  initialize
fi
if ! [ -s remaining ] && [[ $(find running.*/cmdln 2>/dev/null | wc -l) == 0 ]]; then
    rm -rf running.*/
    msg "Nothing remaining for $queue"
    exit 2
fi

# register worker pid
workerHandle=
register-pid() {
    local id=0
    local handle=
    while handle=worker-"$id".lock
        lockproc $handle alive
    do let ++id
    done
    lockproc $handle grab
    workerHandle=$handle
}
synchronized workers.lock register-pid

# repeat until all "remaining" runs are done
msg "Starting $queue"
count=$(cat count || wc -l <plan)
abort=false
trap "abort=true" INT QUIT TERM
while [ -s remaining ] && ! $abort; do
    run=
    pick-next() {
        # check if there's any running item which isn't alive
        for r in running.*/; do
            [ -d "$r" ] || continue
            [ -s "$r"/cmdln ] || continue
            ! lockproc $r/lock alive || continue
            lockproc $r/lock grab || continue
            msg +2 " resuming $r..."
            run=$r; break
        done
        # otherwise, dequeue from remaining
        if ! [ -d "$run" ]; then
            run=$(mktemp -d running.XXX)
            lockproc $run/lock grab || continue
            head -n 1 remaining >$run/cmdln
            { echo 1d; echo wq; } | ed remaining &>/dev/null
        fi
    }
    synchronized remaining.lock  pick-next || continue
    # run the one we picked for next
    line=$(cat $run/cmdln)
    serial=${line##*"#"}
    cmdln=${line%"#"*}
    _3X_RUN=$(new-run-id)
    runRelPath="../../../${_3X_RUN#run/}"
    msg "Batch #$serial/$count of $queue as $_3X_RUN"
    ln -sfn "$runRelPath" $run/run
    _3X_RUN=$_3X_RUN $cmdln || true
    ! $abort || break
    # after it ends, record the run in the "done" queue
    record() {
        ln -sfn "$runRelPath" runs/$serial
        echo "$line" >>"done"
    }
    synchronized done.lock  record
    rm -rf "$run"
    #lockproc $run/lock release || true # no need to release the removed lock
done

# unregister worker pid
lockproc $workerHandle release

if $abort; then
    error "Aborted $queue" || true
    msg "To resume, run:"
    msg "  3x start"
    exit 2
else
    msg "Done $queue"
fi

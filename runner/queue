#!/usr/bin/env bash
# queue -- Command-line interface to manipulating queue entries
# 
# This command works with an SQLite database named 'queue.db', kept under the
# current queue directory.  Following subcommands are available to manipulate
# entries of such database.
# 
# To list all entries in the queue:
# > queue list
# 
# To list only 100 entries starting from the 201st entry:
# > LIMIT=100 OFFSET=201 \
# > queue list
# 
# 
# To add PLANNED entries to the queue:
# > queue plan-more <<EOF
# > x=1 y=foo z=bar
# > x=2 y=bar z=baz
# > EOF
# 
# To replace PLANNED entries of the queue with the ones supplied as input:
# > queue plan <<EOF
# > x=3 y=foo z=baz
# > EOF
# 
# 
# To pick the first PLANNED entry in the queue and mark it as RUNNING:
# > serial=$(queue pick 1 RUNNING)
# > ...
# 
# Similarly, to pick the first 100 PLANNED entries in the queue:
# > queue pick 100 RUNNING |
# > while read serial; do
# >     ...
# > done
# 
# 
# Using the serials of entries, we can selectively
# change the state of particular entries in the queue:
# > queue mark-as DONE    $serial
# > queue mark-as FAILED  98 99
# > queue mark-as PLANNED 100 101 102
# 
# Move some of the PLANNED entries to the front of the queue:
# > queue prioritize 102 104 108 ...
# Or, to the rear:
# > queue postpone   101 103 105 107 ...
# 
# And remove from the queue:
# > queue cancel     100 106 ...
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-09-17
set -eu

[ $# -gt 0 ] || usage "$0" ""

BATCHSIZE=256

. find-queue.sh
. sql-vocabs.sh

DB="$_3X_QUEUE_DIR"/queue.db
sqlite() { sqlite3 -bail "$DB" "$@"; }
be-quiet +3 ||
sqlite() { tee /dev/stderr | sqlite3 -bail "$DB" "$@"; }
inputs=$(3x-inputs)

dedup-serials() {
    awk '{
        serial=$0; sub(/^.*#/, "", serial)
        if (seen[serial]++) {
            sub("#" serial, "")
        }
        print
    }'
}

# make sure a proper queue database exists
if ! [ -s $DB ]; then
    # TODO check schema to see if new columns are added
    sqlite <<-EOF
	BEGIN TRANSACTION;
	CREATE TABLE IF NOT EXISTS queue
	( serial   INTEGER PRIMARY KEY ASC AUTOINCREMENT
	, ordinal  INTEGER UNIQUE NOT NULL
	, state    TEXT           DEFAULT 'PLANNED'
	, target   TEXT           DEFAULT NULL
	, runId    TEXT    UNIQUE DEFAULT NULL
	$(
	for varName in $inputs; do
	    echo ", _$varName $(sql-type $varName) DEFAULT NULL"
	done
	)
	);
	CREATE UNIQUE INDEX IF NOT EXISTS queueOrdering
	ON queue (ordinal ASC);
	COMMIT;
	EOF
fi

Cmd=$1; shift
case $Cmd in

    list)
        cols="state"             #header="state#"
        for varName in $inputs; do
            cols+=", '$varName=' || _$varName"  #header+="\t$varName"
        done
        cols+=", '#' || serial"  #header+="\tserial#"
        cols+=", target"         #header+="\ttarget#"
        cols+=", runId"          #header+="\trun#"
        # compile selection expression from arguments
        where=$(compile-where "$@")
        #echo -e "$header"
        sqlite <<-EOF
	.header OFF
	.mode tabs
	.nullvalue ""
	SELECT $cols FROM queue $where ORDER BY ordinal;
	EOF
        ;;


    plan)
        dedup-serials | {
            echo "BEGIN TRANSACTION;"
            echo "DELETE FROM queue WHERE state='PLANNED';"
            printRecordExpr=$(sql-values-expr "%s, (%s)" $inputs)
            numRecs=0
            while read -r run; do
                if [[ $numRecs -eq 0 ]]; then
                    echo "INSERT OR REPLACE INTO queue"
                    echo "($(printf "_%s,\t" $inputs) serial, ordinal) VALUES "
                else
                    echo ","
                fi
                let ++numRecs
                # parse line and print corresponding row values
                run=${run#run}
                case $run in
                    *"#"[0-9]*)
                        serial=${run##*#}
                        serial=${serial%%[[:space:]]*}
                        serial="'$serial'" ;;
                    *)  serial=NULL        ;;
                esac
                eval "(
                $run
                $printRecordExpr  '$serial' \
                    '(SELECT COALESCE(MAX(ordinal),0) FROM queue)+$numRecs'
                )"
                if [[ $numRecs -ge $BATCHSIZE ]]; then
                    echo ";"
                    numRecs=0
                fi
            done
            [[ $numRecs -eq 0 ]] || echo ";"
            echo "COMMIT;"
        } | sqlite
        ;;

    plan-more)
        {
            echo "BEGIN TRANSACTION;"
            printRecordExpr=$(sql-values-expr "(%s)" $inputs)
            numRecs=0
            while read -r run; do
                if [[ $numRecs -eq 0 ]]; then
                    echo "INSERT INTO queue"
                    echo "($(printf "_%s,\t" $inputs) ordinal) VALUES"
                else
                    echo ","
                fi
                let ++numRecs
                # parse line and print corresponding row values
                run=${run#run}
                eval "(
                $run
                $printRecordExpr  \
                    '(SELECT COALESCE(MAX(ordinal),0) FROM queue)+$numRecs'
                )"
                if [[ $numRecs -ge $BATCHSIZE ]]; then
                    echo ";"
                    numRecs=0
                fi
            done
            [[ $numRecs -eq 0 ]] || echo ";"
            echo "COMMIT;"
        } | sqlite
        ;;


    pick)
        error "$Cmd: Not implemented"
        ;;

    mark-as)
        error "$Cmd: Not implemented"
        ;;


    duplicate)
        {
            echo "BEGIN TRANSACTION;"
            for serial; do
                echo "INSERT INTO queue"
                cols=$(printf "_%s,\t" $inputs)
                echo "($cols ordinal)"
                echo "SELECT $cols (SELECT COALESCE(MAX(ordinal),0) FROM queue)+1"
                echo "FROM queue"
                echo "WHERE serial=$serial"
                echo ";"
            done
            echo "COMMIT;"
        } | sqlite
        ;;

    prioritize)
        error "$Cmd: Not implemented"
        ;;

    postpone)
        error "$Cmd: Not implemented"
        ;;

    cancel)
        [ $# -gt 0 ] || usage "$0" "No SERIAL given to $Cmd"
        {
            echo "BEGIN TRANSACTION;"
            for serial; do
                echo "DELETE FROM queue WHERE serial=$serial AND state='PLANNED';"
            done
            echo "COMMIT;"
        } | sqlite
        ;;


    *)
        usage "$0" "queue $Command: Unrecognized subcommand"
        ;;

esac

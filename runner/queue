#!/usr/bin/env bash
# queue -- Command-line interface to manipulating queue entries
# 
# This command works with an SQLite database named 'queue.db', kept under the
# current queue directory.  Following subcommands are available to manipulate
# entries of such database.
# 
# To list all entries in the queue:
# > queue list
# 
# To list only 100 entries starting from the 201st entry:
# > LIMIT=100 OFFSET=201 \
# > queue list
# 
# 
# To add PLANNED entries to the queue:
# > queue plan-more <<EOF
# > x=1 y=foo z=bar
# > x=2 y=bar z=baz
# > EOF
# 
# To replace PLANNED entries of the queue with the ones supplied as input:
# > queue plan <<EOF
# > x=3 y=foo z=baz
# > EOF
# 
# 
# To pick the first PLANNED entry in the queue and mark it as RUNNING:
# > serial=$(queue pick 1 RUNNING)
# > ...
# 
# Similarly, to pick the first 100 PLANNED entries in the queue:
# > queue pick 100 RUNNING |
# > while read serial; do
# >     ...
# > done
# 
# 
# Using the serials of entries, we can selectively
# change the state of particular entries in the queue:
# > queue mark-as DONE    $serial
# > queue mark-as FAILED  98 99
# > queue mark-as PLANNED 100 101 102
# 
# Move some of the PLANNED entries to the front of the queue:
# > queue prioritize 102 104 108 ...
# Or, to the rear:
# > queue postpone   101 103 105 107 ...
# 
# And remove from the queue:
# > queue cancel     100 106 ...
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-09-17
set -eu

[ $# -gt 0 ] || usage "$0" ""

BATCHSIZE=256

. find-queue.sh
. sql-vocabs.sh

DB="$_3X_QUEUE_DIR"/queue.db
sqlite() { sqlite3 -bail "$DB" "$@"; }
be-quiet +3 ||
sqlite() { tee /dev/stderr | sqlite3 -bail "$DB" "$@"; }
inputs=$(3x-inputs)

dedup-serials() {
    awk '{
        serial=$0; sub(/^.*#/, "", serial)
        if (seen[serial]++) {
            sub("#" serial, "")
        }
        print
    }'
}

# make sure a proper queue database exists
if ! [ -s $DB ]; then
    # TODO check schema to see if new columns are added
    sqlite <<-EOF
	BEGIN TRANSACTION;
	CREATE TABLE IF NOT EXISTS queue
	( serial   INTEGER PRIMARY KEY ASC AUTOINCREMENT
	, ordinal  INTEGER UNIQUE NOT NULL
	, state    TEXT           DEFAULT 'PLANNED'
	, target   TEXT           DEFAULT NULL
	, runId    TEXT    UNIQUE DEFAULT NULL
	$(
	for varName in $inputs; do
	    echo ", _$varName $(sql-type $varName) DEFAULT NULL"
	done
	)
	);
	CREATE UNIQUE INDEX IF NOT EXISTS queueOrdering
	ON queue (ordinal ASC);
	COMMIT;
	EOF
fi

Cmd=$1; shift
case $Cmd in

    list)
        cols="state"             #header="state#"
        for varName in $inputs; do
            cols+=", '$varName=' || _$varName"  #header+="\t$varName"
        done
        cols+=", '#' || serial"  #header+="\tserial#"
        cols+=", target"         #header+="\ttarget#"
        cols+=", runId"          #header+="\trun#"
        # compile selection expression from arguments
        where=$(compile-where "$@")
        #echo -e "$header"
        sqlite <<-EOF
	.header OFF
	.mode tabs
	.nullvalue ""
	SELECT $cols FROM queue $where ORDER BY ordinal;
	EOF
        ;;


    plan)
        dedup-serials | {
            echo "BEGIN TRANSACTION;"
            echo "DELETE FROM queue WHERE state='PLANNED';"
            printRecordExpr=$(sql-values-expr "%s, (%s)" $inputs)
            numRecs=0
            while read -r run; do
                if [[ $numRecs -eq 0 ]]; then
                    echo "INSERT OR REPLACE INTO queue ($(printf "_%s,\t" $inputs) serial, ordinal)"
                    echo "VALUES"
                else
                    echo ","
                fi
                let ++numRecs
                # parse line and print corresponding row values
                run=${run#run}
                case $run in
                    *"#"[0-9]*)
                        serial=${run##*#}
                        serial=${serial%%[[:space:]]*}
                        serial="'$serial'" ;;
                    *)  serial=NULL        ;;
                esac
                eval "(
                $run
                $printRecordExpr  '$serial' \
                    '(SELECT COALESCE(MAX(ordinal),0) FROM queue)+$numRecs'
                )"
                if [[ $numRecs -ge $BATCHSIZE ]]; then
                    echo ";"
                    numRecs=0
                fi
            done
            [[ $numRecs -eq 0 ]] || echo ";"
            echo "COMMIT;"
        } | sqlite
        ;;

    plan-more)
        {
            echo "BEGIN TRANSACTION;"
            printRecordExpr=$(sql-values-expr "(%s)" $inputs)
            numRecs=0
            while read -r run; do
                if [[ $numRecs -eq 0 ]]; then
                    echo "INSERT INTO queue ($(printf "_%s,\t" $inputs) ordinal)"
                    echo "VALUES"
                else
                    echo ","
                fi
                let ++numRecs
                # parse line and print corresponding row values
                run=${run#run}
                eval "(
                $run
                $printRecordExpr  \
                    '(SELECT COALESCE(MAX(ordinal),0) FROM queue)+$numRecs'
                )"
                if [[ $numRecs -ge $BATCHSIZE ]]; then
                    echo ";"
                    numRecs=0
                fi
            done
            [[ $numRecs -eq 0 ]] || echo ";"
            echo "COMMIT;"
        } | sqlite
        ;;


    pick)
        error "$Cmd: Not implemented"
        ;;

    mark-as)
        error "$Cmd: Not implemented"
        ;;


    duplicate)
        [ $# -gt 0 ] || usage "$0" "No SERIAL given to $Cmd"
        {
            echo "BEGIN TRANSACTION;"
            cols=$(printf "_%s,\t" $inputs)
            for serial; do
                echo "INSERT INTO queue ($cols ordinal)"
                echo "SELECT $cols (SELECT COALESCE(MAX(ordinal),0) FROM queue)+1"
                echo "FROM queue WHERE serial=$serial;"
            done
            echo "COMMIT;"
        } | sqlite
        ;;

    prioritize)
        [ $# -gt 0 ] || usage "$0" "No SERIAL given to $Cmd"
        {
            serials=$(sql-csv NUM "$@")
            numPLANNED="(SELECT COUNT(1) FROM queue WHERE state='PLANNED')"
            firstOrdinal="(SELECT COALESCE(MAX(ordinal),0) FROM queue WHERE state<>'PLANNED')+1"
            minOrdinal="(SELECT MIN(ordinal) FROM order_$$)"
            maxOrdinal="(SELECT MAX(ordinal) FROM order_$$)"
            #debug() { local sql=${1#(}; sql=${sql%)}; echo "$sql;"; }
            #echo ".nullvalue \"NULL\""
            echo "BEGIN TRANSACTION;"
            # add the prioritized ones to a temporary table
            echo "CREATE TEMPORARY TABLE IF NOT EXISTS order_$$ AS"
            echo " SELECT serial, NULL AS ordinal FROM queue"
            echo " WHERE serial IN ( $serials ) AND state='PLANNED';"
            #debug "${firstOrdinal%+1}"
            #debug "$minOrdinal"
            #debug "$maxOrdinal"
            #debug "SELECT * FROM order_$$ ORDER BY ordinal"
            # assign the minimum ordinal to the first of prioritized ones
            for serial; do
                echo "UPDATE order_$$ SET ordinal"
                echo " =$firstOrdinal"
                echo "WHERE serial=$serial"
                echo "  AND $minOrdinal IS NULL;"
            done
            #debug "SELECT * FROM order_$$ ORDER BY ordinal"
            for serial; do
                echo "UPDATE order_$$ SET ordinal"
                echo " =1 + $maxOrdinal"
                echo "WHERE serial=$serial"
                echo "  AND ordinal IS NULL;"
            done
            #debug "SELECT * FROM order_$$ ORDER BY ordinal"
            # make a gap in queue's ordinals for later
            echo "UPDATE queue SET ordinal"
            echo " =ordinal + $numPLANNED"
            echo "WHERE state='PLANNED';"
            # append the rest to the temporary table
            echo "INSERT OR REPLACE INTO order_$$ (serial, ordinal)"
            echo " SELECT serial, ordinal FROM queue"
            echo " WHERE state='PLANNED' AND serial NOT IN ( $serials )"
            echo " ORDER BY ordinal;"
            #debug "SELECT * FROM order_$$ ORDER BY ordinal;"
            # assign consecutive ordinals
            echo "UPDATE order_$$ SET ordinal"
            echo " =$minOrdinal"
            echo " +(SELECT COUNT(1) FROM order_$$ AS o"
            echo "   WHERE o.ordinal < order_$$.ordinal)"
            echo "WHERE ordinal >= $minOrdinal + $numPLANNED;"
            #debug "SELECT * FROM order_$$ ORDER BY ordinal"
            #debug "SELECT * FROM queue ORDER BY ordinal"
            # reflect new ordinals back to queue
            echo "UPDATE queue SET ordinal"
            echo " =(SELECT o.ordinal FROM order_$$ AS o WHERE o.serial = queue.serial)"
            echo "WHERE state='PLANNED';"
            #debug "SELECT * FROM queue ORDER BY ordinal"
            echo "DROP TABLE order_$$;"
            echo "COMMIT;"
        } | sqlite
        ;;

    postpone)
        error "$Cmd: Not implemented"
        ;;

    cancel)
        [ $# -gt 0 ] || usage "$0" "No SERIAL given to $Cmd"
        {
            echo "BEGIN TRANSACTION;"
            for serial; do
                echo "DELETE FROM queue WHERE serial=$serial AND state='PLANNED';"
            done
            echo "COMMIT;"
        } | sqlite
        ;;


    *)
        usage "$0" "queue $Command: Unrecognized subcommand"
        ;;

esac

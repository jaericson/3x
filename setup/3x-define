#!/usr/bin/env bash
# 3x-define -- Define element of the experiment
# 
# > 3x define [-f] WHAT NAME HOW...
# > 3x define program  COMMAND...
# > 3x define input    NAME[(UNIT)][:TYPE] VALUE1 [VALUE2]...
# > 3x define output   NAME[(UNIT)][:TYPE] extract  REGEXP_BEFORE  REGEXP  REGEXP_AFTER  [FROM_FILENAME]...
# > 3x define output   NAME[(UNIT)][:TYPE] extract  REGEXP_BEFORE  REGEXP  REGEXP_AFTER  --running COMMAND --caching FILENAME
# > 3x define output   NAME:MIMETYPE       file     FILENAME
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-24
set -eu

. find-run-archive.sh

_3X_ROOT=$(3x-findroot)
export _3X_ROOT

# process options
ForceRedefine=false
while getopts "f" o; do
    case $o in
        f)
            ForceRedefine=true
            ;;
    esac
done
shift $(($OPTIND - 1))

# process arguments
[ $# -gt 0 ] || usage "$0" "WHAT to define is missing"
What=$1; shift

case $What in
    input|output)
        [ $# -gt 0 ] || usage "$0" "NAME is missing"
        Name=$1; shift
        ;;
esac

# skip maintenance of index and queues if we're in the middle of a setup
maintainIndexes=true
! ${_3X_SETUP_IN_PROGRESS:-false} || maintainIndexes=false

. sanity-checks.sh

# TODO expand glob pattern in any arguments?

cd "$_3X_ROOT"

case $What in
    program)
        dir="program"
        runner="$dir/$_3X_API_RUNNER"
        $ForceRedefine || ! [ -e "$runner" ] || error "program already defined"
        mkdir -p "$dir"
        touch "$dir"/env
        {
            echo "#!/usr/bin/env bash"
            for Command; do
                echo "$Command"
            done
        } >"$runner"
        chmod +x "$runner"
        ;;

    input)
        extractUnitFromName
        extractTypeFromName nominal # TODO default is nominal, but may we can try recognition
        dir="input/$Name="
        checkIfNameIsSane "$Name" "$dir"
        $ForceRedefine || ! [ -d "$dir" ] || error "$Name: input already defined"
        for Value; do
            checkIfValueIsSane "$Value" "$Name" "$dir/$Value"
        done
        # TODO check validity of $Unit, $Type
        for Value; do
            vdir="$dir/$Value"
            mkdir -p "$vdir"
            touch "$vdir"/env
        done
        [ -z "$Unit" ] || echo "$Unit" >"$dir"/unit
        echo "$Type" >"$dir"/datatype
        # TODO decide what to do with the other ones not mentioned
        ;;

    output)
        outputType=${1:-}; shift || true
        extractUnitFromName
        extractTypeFromName
        dir="output/$Name"
        checkIfNameIsSane "$Name" "$dir"
        extractor="$dir/$_3X_API_EXTRACTOR"
        $ForceRedefine || ! [ -x "$extractor" ] || error "$Name: output already defined"
        # TODO check validity of $Unit, $Type
        case $outputType in 
            extract)
                [ $# -gt 0 ] || usage "$0" "Missing REGEXP_BEFORE"
                [ $# -gt 1 ] || usage "$0" "Missing REGEXP"
                [ $# -gt 2 ] || usage "$0" "Missing REGEXP_AFTER"
                RegExps=("$1" "$2" "$3"); shift 3
                [ $# -gt 0 ] || set -- rusage stdout stderr  # filenames to scan
                # handle options
                o_running=
                o_caching=
                case $1 in
                    --*)
                        while o=${1:-}; shift 2>/dev/null; do
                            case $o in
                                --running|--caching)
                                    oName=${o#--}
                                    declare "o_$oName=$1"
                                    shift
                                    ;;
                                *)
                                    error "$o: unrecognized argument"
                            esac
                        done
                esac
                : ${Type:=ratio} # default type is ratio
                mkdir -p "$dir"
                {
                    echo "#!/usr/bin/env bash"
                    echo "set -eu"
                    if [ -n "$o_running" ]; then
                        if [ -n "$o_caching" ]; then
                            f=$(escape-args-for-shell outputs/"$o_caching")
                            echo "if [ -s $f ]"
                            echo "then cat $f"
                            echo "else touch $f"
                            echo "    set -o pipefail"
                            echo "    {"
                            echo "$o_running"
                            echo "    } | tee $f.\$\$"
                            echo "    mv -f $f.\$\$ $f"
                            echo "fi |"
                        else
                            echo "$o_running |"
                        fi
                    else
                        echo "$(escape-args-for-shell cat "$@") |"
                    fi
                    echo -n "extract-regexp "; escape-args-for-shell "${RegExps[@]}"
                } >"$extractor"
                ;;
            file)
                [ $# -gt 0 ] || usage "$0" "Missing FILENAME"
                [ $# -eq 1 ] || usage "$0" "Too many FILENAMEs"
                [ -n "$Type" ] || usage "$0" "Missing MIMETYPE"
                checkIfMimeTypeIsValid "$Type" "$Type"
                [ -z "$Unit" ] || usage "$0" "($Unit): file output variables cannot have UNIT defined"
                mkdir -p "$dir"
                {
                    echo "#!/bin/sh -e"
                    f=$(escape-args-for-shell "workdir/$1")
                    echo "[ -e $f ] && echo $f"
                } >"$extractor"
                ;;
            *)
                usage "$0" "Unknown output type $outputType: must be \`file' or \`extract'"
                ;;
        esac
        chmod +x "$extractor"
        if [ -n "$Unit" ]; then
            echo "$Unit" >"$dir"/unit
        else
            rm -f "$dir"/unit
        fi
        echo "$Type" >"$dir"/datatype
        ;;

    commit)
        maintainIndexes=true
        ;;
esac

if $maintainIndexes; then
    # re-initialize index
    3x-index migrate &
    case $What in
        input)
            # migrate existing queues
            SHLVL=$(( $SHLVL - 1 )) \
            queue migrate # TODO for every queue
            ;;

        output)
            # extract output from existing runs
            SHLVL=$(( $SHLVL - 1 )) \
            _3X_RESCAN_ONLY=$Name \
            3x-rescan -f
            ;;
    esac
    wait
fi
